C51 COMPILER V9.59.0.0   USART                                                             09/19/2018 10:35:40 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\Usart.obj
COMPILER INVOKED BY: F:\Keil_v5_C51\C51\BIN\C51.EXE ..\MyLib\src\Usart.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Protocol;..\
                    -Mode\inc;..\MyLib\inc;..\Lib\inc;..\User) DEBUG OBJECTEXTEND PRINT(.\Listings\Usart.lst) TABS(2) OBJECT(.\Objects\Usart.
                    -obj)

line level    source

   1          #include "STC8A8K32S4A12.h"
   2          
   3          #include "Usart.h"
   4          #include "Gprs.h"
   5          #include "Packet.h"
   6          #include "Order.h"
   7          #include "EEPROM.h"
   8          #include "PublicFunction.h"
   9          
  10          #include "string.h"
  11          
  12          #define FOSC 24000000UL
  13          #define BRT (65536 - FOSC / 115200 / 4)
  14          
  15          void Uart1_Init(void)
  16          {
  17   1          SCON = 0x50;    //8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
  18   1          AUXR = 0x40;    //å®šæ—¶å™¨1æ—¶é’Ÿä¸ºFosc,å³1T
  19   1          AUXR &= 0xFE;   //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  20   1          TMOD = 0x00;    //è®¾å®šå®šæ—¶å™¨1ä¸º16ä½è‡ªåŠ¨é‡è£…æ–¹å¼
  21   1          TL1 = BRT;      //è®¾å®šå®šæ—¶åˆå€¼
  22   1          TH1 = BRT >> 8; //è®¾å®šå®šæ—¶åˆå€¼
  23   1          ET1 = 0;        //ç¦æ­¢å®šæ—¶å™¨1ä¸­æ–­
  24   1          TR1 = 1;        //å¯åŠ¨å®šæ—¶å™¨1
  25   1          //BUSY = 0;
  26   1          //P3M1 = 0x00;
  27   1          //P3M0 = 0x03;
  28   1          EA = 1;
  29   1          ES = 1;
  30   1      }
  31          
  32          void Uart1_Send(unsigned char Buf)
  33          {
  34   1          SBUF = Buf;
  35   1          while (!TI)
  36   1              ;
  37   1          TI = 0;
  38   1      }
  39          
  40          void Uart1_Send_Data(unsigned char *Buf)
  41          {
  42   1          while (*Buf)
  43   1          {
  44   2              Uart1_Send(*Buf++);
  45   2          }
  46   1      }
  47          
  48          int Uart1_Recv_NUM_AT(void)
  49          {
  50   1          char xdata *RecStr = Rx_Buffer_AT;
  51   1          char xdata Num = 0;
  52   1          int xdata Count = 0;
  53   1      Loop:
C51 COMPILER V9.59.0.0   USART                                                             09/19/2018 10:35:40 PAGE 2   

  54   1          *RecStr = SBUF;
  55   1          Count = 0;
  56   1          RI = 0;
  57   1          if (Num < 50) //æ•°æ®åŒ…é•¿åº¦ä¸º36ä¸ªå­—ç¬¦,å°è¯•è¿ç»­æ¥æ”¶36ä¸ªå­—ç¬¦
  58   1          {
  59   2              Num++;
  60   2              RecStr++;
  61   2              while (!RI)
  62   2              {
  63   3                  P50 = 0;
  64   3                  Count++;
  65   3                  if (Count > 200)
  66   3                  {
  67   4                      P50 = 1;
  68   4                      return 0; //æ¥æ”¶æ•°æ®ç­‰å¾…å»¶è¿Ÿï¼Œç­‰å¾…æ—¶é—´å¤ªä¹…ä¼šå¯¼è‡´CPUè¿ç®—é—²ç½®ï¼Œå¤ªçŸ­
             -ä¼šå‡ºç°"æ•°æ®åŒ…è¢«åˆ†å‰²",é»˜è®¤count=130
  69   4                  }
  70   3              }
  71   2              goto Loop;
  72   2          }
  73   1          P50 = 1;
  74   1          return 1;
  75   1      }
  76          
  77          int Uart1_Recv_NUM_Packet(void)
  78          {
  79   1          char xdata *RecStr = Rx_Buffer;
  80   1          char xdata Num = 0;
  81   1          int xdata Count = 0;
  82   1      Loop:
  83   1          *RecStr = SBUF;
  84   1          Count = 0;
  85   1          RI = 0;
  86   1          if (Num < 35) //æ•°æ®åŒ…é•¿åº¦ä¸º36ä¸ªå­—ç¬¦,å°è¯•è¿ç»­æ¥æ”¶36ä¸ªå­—ç¬¦
  87   1          {
  88   2              Num++;
  89   2              RecStr++;
  90   2              while (!RI)
  91   2              {
  92   3                  P51 = 0;
  93   3                  Count++;
  94   3                  if (Count > 200)
  95   3                  {
  96   4                      P51 = 1;
  97   4                      //Send_OK_Flag = False;
  98   4                      return 0; //æ¥æ”¶æ•°æ®ç­‰å¾…å»¶è¿Ÿï¼Œç­‰å¾…æ—¶é—´å¤ªä¹…ä¼šå¯¼è‡´CPUè¿ç®—é—²ç½®ï¼Œå¤ªçŸ­
             -ä¼šå‡ºç°"æ•°æ®åŒ…è¢«åˆ†å‰²",é»˜è®¤count=130
  99   4                  }
 100   3              }
 101   2              goto Loop;
 102   2          }
 103   1          P51 = 1;
 104   1          //Send_OK_Flag = False;
 105   1          return 1;
 106   1      }
 107          
 108          void Uart1_Recv_Deal(void)
 109          {
 110   1          int xdata Check;
 111   1          int xdata HCheck;
 112   1          int xdata LCheck;
 113   1          //æå–æ•°æ®åŒ…ä¸­çš„æ•°æ®ï¼Œå¹¶å­˜å‚¨åˆ°æœ¬åœ°å˜é‡ä¸­
C51 COMPILER V9.59.0.0   USART                                                             09/19/2018 10:35:40 PAGE 3   

 114   1          DeviceID_01 = Rx_Buffer[0];
 115   1          DeviceID_02 = Rx_Buffer[1];
 116   1          DeviceID_03 = Rx_Buffer[2];
 117   1          DeviceID_04 = Rx_Buffer[3];
 118   1          DeviceMode = Rx_Buffer[4];
 119   1          Order = Rx_Buffer[5];
 120   1          DeviceStatus = Rx_Buffer[6];
 121   1          DeviceFlow_01 = Rx_Buffer[7];
 122   1          DeviceFlow_02 = Rx_Buffer[8];
 123   1          RechargeFlow_01 = Rx_Buffer[9];
 124   1          RechargeFlow_02 = Rx_Buffer[10];
 125   1          RechargeDay_01 = Rx_Buffer[11];
 126   1          RechargeDay_02 = Rx_Buffer[12];
 127   1          SurplusFlow_01 = Rx_Buffer[13];
 128   1          SurplusFlow_02 = Rx_Buffer[14];
 129   1          SurplusDay_01 = Rx_Buffer[15];
 130   1          SurplusDay_02 = Rx_Buffer[16];
 131   1          UsedFlow_01 = Rx_Buffer[17];
 132   1          UsedFlow_02 = Rx_Buffer[18];
 133   1          UsedDay_01 = Rx_Buffer[19];
 134   1          UsedDay_02 = Rx_Buffer[20];
 135   1          WaterTDS_01 = Rx_Buffer[21];
 136   1          WaterTDS_02 = Rx_Buffer[22];
 137   1          GPRSSignal = Rx_Buffer[23];
 138   1          ICCID1_01 = Rx_Buffer[24];
 139   1          ICCID1_02 = Rx_Buffer[25];
 140   1          ICCID2_01 = Rx_Buffer[26];
 141   1          ICCID2_02 = Rx_Buffer[27];
 142   1          ICCID3_01 = Rx_Buffer[28];
 143   1          ICCID3_02 = Rx_Buffer[29];
 144   1          ICCID4_01 = Rx_Buffer[30];
 145   1          ICCID4_02 = Rx_Buffer[31];
 146   1          ICCID5_01 = Rx_Buffer[32];
 147   1          ICCID5_02 = Rx_Buffer[33];
 148   1          Check_01 = Rx_Buffer[34];
 149   1          Check_02 = Rx_Buffer[35];
 150   1          //è®¡ç®—æ ¡éªŒä½
 151   1          Clear_Buf(Rx_Buffer);
 152   1          Check = DeviceID_01 + DeviceID_02 + DeviceID_03 + DeviceID_04 + DeviceMode + Order + DeviceStatus + De
             -viceFlow_01 + DeviceFlow_02 + RechargeFlow_01 + RechargeFlow_02 + RechargeDay_01 + RechargeDay_02 + SurplusFlow_01 + Sur
             -plusFlow_02 + SurplusDay_01 + SurplusDay_02 + UsedFlow_01 + UsedFlow_02 + UsedDay_01 + UsedDay_02 + WaterTDS_01 + WaterT
             -DS_02 + GPRSSignal + ICCID1_01 + ICCID1_02 + ICCID2_01 + ICCID2_02 + ICCID3_01 + ICCID3_02 + ICCID4_01 + ICCID4_02 + ICC
             -ID5_01 + ICCID5_02;
 153   1          HCheck = (short)(Check >> 8);   //æå–æ ¡éªŒä½é«˜å…«ä½
 154   1          LCheck = (short)(Check & 0xff); //æå–æ ¡éªŒä½ä½å…«ä½
 155   1          if(Check_02 != LCheck)
 156   1              Order = COMMAND_ERRORUPLOAD; 
 157   1          // if ((Check_01 != HCheck) && (Check_02 != LCheck)) //æ¯”è¾ƒè®¡ç®—çš„æ ¡éªŒä½æ˜¯å¦ä¸æ•°æ®åŒ…ä¸­æ 
             -¡éªŒä½ç›¸ç­‰
 158   1          // {
 159   1          //     Order = COMMAND_ERRORUPLOAD;
 160   1          // }
 161   1      }
 162          
 163          void Clear_Buf(char *Rx_Buf)
 164          {
 165   1          memset(Rx_Buf, 0x00, MAX_SIZE);
 166   1      }
 167          
 168          void Uart1_Isr(void) interrupt 4 using 1
 169          {
 170   1          //ES = 0;
C51 COMPILER V9.59.0.0   USART                                                             09/19/2018 10:35:40 PAGE 4   

 171   1          if (Send_OK_Flag == True)
 172   1          {
 173   2              if (Uart1_Recv_NUM_Packet())
 174   2              {
 175   3                  //æ•°æ®åŒ…é•¿åº¦æ­£ç¡®åˆ™æ‰§è¡Œä»¥ä¸‹ä»£ç 
 176   3                  Uart1_Recv_Deal();
 177   3              }
 178   2          }
 179   1          else
 180   1          {
 181   2              Uart1_Recv_NUM_AT();
 182   2          }
 183   1          //RI = 0; //æ¥æ”¶å¹¶å¤„ç†ä¸€æ¬¡æ•°æ®åæŠŠæ¥æ”¶ä¸­æ–­æ ‡å¿—æ¸…é™¤ä¸€ä¸‹ï¼Œæ‹’ç»å“åº”åœ¨ä¸­æ–­æ¥
             -æ”¶å¿™çš„æ—¶å€™å‘æ¥çš„è¯·æ±‚
 184   1          //ES = 1;
 185   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    987    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
